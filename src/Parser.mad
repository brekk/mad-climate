import type { Maybe } from "Maybe"

import { EQ, GT, LT } from "Compare"
import Fn from "Function"
import IO from "IO"
import List from "List"
import { fromMaybe } from "Maybe"
import {} from "Scan"
import String from "String"
import Terminal from "Terminal"



equals = Fn.equals
ifElse = Fn.ifElse
K = Fn.always

export alias ArgvParser a = String -> a
// export alias CommandCore a = {
//   aliases :: List String,
//   isArray :: Boolean,
//   name :: Maybe String,
//   parser :: ArgvParser a,
// }
alias Name = String
alias Aliases = List String
alias Description = String
export type Modifier
  = Repeatable(Integer)
  | Invalid(String)
  | Modal
  | CmdString
  | CmdBool
  | CmdInt
  | CmdFloat
export type Instruction = Command(List Modifier, String, List String, String) | Issue(String)
export type Configuration = Configuration(String, String, List Instruction)

flag :: String -> String
flag = mappend("--")

shortFlag :: String -> String
shortFlag = mappend("-")

enflag :: String -> String
enflag = ifElse(
  pipe(
    String.length,
    equals(1),
  ),
  pipe(
    shortFlag,
    IO.green,
  ),
  pipe(
    flag,
    IO.yellow,
  ),
)

// summarizeAliases :: List String -> String
summarizeAliases = where {
  [] =>
    ``

  [x] =>
    enflag(x)

  [x, ...rest] =>
    `${Terminal.text.bold(flag(x))} (${
      pipe(
        List.sortBy(
          (a, b) => {
            aa = String.length(a)
            bb = String.length(b)
            return aa == bb ? EQ : aa < bb ? GT : LT
          },
        ),
        map(enflag),
        String.join(" | "),
      )(rest)
    })`
}

stringKind = where {
  [Repeatable(n), ...x] =>
    [...stringKind(x)]

  [CmdString, ...x] =>
    ["string", ...stringKind(x)]

  [CmdInt, ...x] =>
    ["integer", ...stringKind(x)]

  [CmdFloat, ...x] =>
    ["float", ...stringKind(x)]

  [CmdBool, ...x] =>
    ["boolean", ...stringKind(x)]

  _ =>
    []
}

parseKindsAsString :: List Modifier -> String
parseKindsAsString = pipe(
  stringKind,
  String.join(" "),
)


summarize :: List Modifier -> String -> List String -> String -> String
summarize = (kinds, name, aliases, description) => `${summarizeAliases([name, ...aliases])}: [${
  IO.red(parseKindsAsString(kinds))
}] - ${description}`

// interpretCommands :: List Instruction -> String
interpretCommands = pipe(
  map(
    where {
      Command(modifiers, name, aliases, description) =>
        where(modifiers) {
          [Invalid(reason), ..._] =>
            "Invalid! " ++ reason

          [Repeatable(n), ..._] =>
            `${summarize(modifiers, name, aliases, description)} - Can be repeated ${
              n < 0 ? "many" : show(n - 1)
            } times!`

          _ =>
            summarize(modifiers, name, aliases, description)
        }
    },
  ),
)

help :: Configuration -> String
export help = where {
  Configuration(name, description, commands) =>
    pipe(
      interpretCommands,
      String.join("\n"),
      mappend(name ++ "\n" ++ description ++ "\n\nFlags:\n"),
    )(commands)
}
