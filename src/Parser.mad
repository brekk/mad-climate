import type { Maybe } from "Maybe"

import { EQ, GT, LT } from "Compare"
import Fn from "Function"
import IO from "IO"
import List from "List"
import { fromMaybe } from "Maybe"
import {} from "Scan"
import String from "String"
import Terminal from "Terminal"



equals = Fn.equals
ifElse = Fn.ifElse
K = Fn.always

export alias ArgvParser a = String -> a
// export alias CommandCore a = {
//   aliases :: List String,
//   isArray :: Boolean,
//   name :: Maybe String,
//   parser :: ArgvParser a,
// }
alias Name = String
alias Aliases = List String
alias Description = String
export type Modifier
  = Repeatable(Integer)
  | Invalid(String)
  | Modal
  | CmdString
  | CmdBool
  | CmdInt
  | CmdFloat
export type Instruction = Command(Modifier, String, List String, String) | Issue(String)
export type Configuration = Configuration(String, String, List Instruction)

flag :: String -> String
flag = mappend("--")

shortFlag :: String -> String
shortFlag = mappend("-")

enflag :: String -> String
enflag = ifElse(
  pipe(
    String.length,
    equals(1),
  ),
  pipe(
    shortFlag,
    IO.green,
  ),
  pipe(
    flag,
    IO.yellow,
  ),
)

// summarizeAliases :: List String -> String
summarizeAliases = where {
  [] =>
    ``

  [x] =>
    enflag(x)

  [x, ...rest] =>
    `${Terminal.text.magenta(flag(x))} (${
      pipe(
        List.sortBy(
          (a, b) => {
            aa = String.length(a)
            bb = String.length(b)
            return aa == bb ? EQ : aa < bb ? GT : LT
          },
        ),
        map(enflag),
        String.join(" | "),
      )(rest)
    })`
}

parseKindAsString :: Modifier -> String
parseKindAsString = where {
  CmdString =>
    "string"

  CmdInt =>
    "integer"

  CmdFloat =>
    "float"

  CmdBool =>
    "boolean"

  _ =>
    ""
}


summarize :: Modifier -> String -> List String -> String -> String
summarize = (kind, name, aliases, description) => `${summarizeAliases([name, ...aliases])}: [${
  IO.red(parseKindAsString(kind))
}] - ${description}`

// interpretCommands :: List Instruction -> String
interpretCommands = pipe(
  map(
    where {
      Command(modifier, name, aliases, description) =>
        where(modifier) {
          Repeatable(n) =>
            `${summarize(CmdInt, name, aliases, description)} - Can be repeated ${
              n < 0 ? "many" : show(n - 1)
            } times!`

          Invalid(reason) =>
            "Invalid! " ++ reason

          _ =>
            summarize(modifier, name, aliases, description)
        }
    },
  ),
)

help :: Configuration -> String
export help = where {
  Configuration(name, description, commands) =>
    pipe(
      interpretCommands,
      String.join("\n"),
      mappend(name ++ "\n" ++ description ++ "\n\nFlags:\n"),
    )(commands)
}
